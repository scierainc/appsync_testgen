// src/renderers/jest.ts
import * as vscode from "vscode";

type OpType = "query" | "mutation" | "subscription";

export interface Scenario {
  id?: string;
  title?: string;
  level?: "unit" | "integration";
  gql: string;
  variables?: Record<string, unknown>;
  expected?: { data?: unknown; errors?: unknown };
  notes?: string;
}

export interface RenderParams {
  operationName: string;
  operationType: OpType;
  scenarios: Scenario[];
}

// Make a safe Jest test filename: letters, numbers, underscores, dots, hyphens
export function makeJestTestFileName(opName: string): string {
  const safe = (opName || "op").replace(/[^A-Za-z0-9_.-]+/g, "_");
  return `${safe}.test.ts`;
}

function safeJsIdent(s: string, fallback: string): string {
  // not used as a JS identifier but keep the style similar to Py renderer
  let out = (s || "").replace(/[^A-Za-z0-9_]+/g, "_");
  out = out.replace(/^_+/, "").replace(/_+$/, "");
  if (!out) out = fallback;
  if (/^[0-9]/.test(out)) out = `${fallback}_${out}`;
  return out;
}

// Escape backticks and ${ in template literals
function escapeForTemplateLiteral(s: string): string {
  return s.replace(/`/g, "\\`").replace(/\$\{/g, "\\${");
}

function gqlAsTemplate(gql: string): string {
  return "`" + escapeForTemplateLiteral(gql || "") + "`";
}

function jsonAsTemplate(obj: unknown): string {
  const json = JSON.stringify(obj ?? {}, null, 2);
  return "`" + escapeForTemplateLiteral(json) + "`";
}

function renderHeader(op: string): string {
  return [
    "// Generated by AppSync TestGen",
    `// Operation: ${op}`,
    `import { gqlRequest } from "../../_shared/jest/graphqlClient";`,
    "",
    "// subset matcher similar to the pytest helper",
    "function subset(exp: any, got: any): boolean {",
    "  if (exp && typeof exp === 'object' && !Array.isArray(exp)) {",
    "    if (!got || typeof got !== 'object' || Array.isArray(got)) return false;",
    "    return Object.entries(exp).every(([k,v]) => subset(v, (got as any)[k]));",
    "  }",
    "  if (Array.isArray(exp)) {",
    "    if (!Array.isArray(got)) return false;",
    "    return exp.every(e => got.some(g => subset(e, g)));",
    "  }",
    "  return Object.is(exp, got);",
    "}",
    ""
  ].join("\n");
}

function renderTest(opName: string, idx: number, sc: Scenario): string {
  // Prefer a human-friendly test title; fall back to id or an index
  const labelBase = sc.title || sc.id || `scenario ${idx + 1}`;
  // We also pass an op/scenario label to gqlRequest so artifacts carry good names
  const scenarioLabel = sc.id || safeJsIdent(labelBase.toLowerCase().replace(/\s+/g, "-"), "scenario");

  const gqlBlock = gqlAsTemplate(sc.gql || "");
  const variablesBlock = jsonAsTemplate(sc.variables ?? {});
  const expectedBlock = jsonAsTemplate(sc.expected ?? {});

  const lines: string[] = [];
  lines.push(`test(${JSON.stringify(labelBase)}, async () => {`);
  lines.push(`  const gql = ${gqlBlock};`);
  lines.push(`  const variables = JSON.parse(${variablesBlock});`);
  lines.push(`  const resp: any = await gqlRequest(gql, variables, { op: ${JSON.stringify(opName)}, scenario: ${JSON.stringify(scenarioLabel)} });`);
  lines.push("");
  lines.push(`  const expected = JSON.parse(${expectedBlock});`);
  lines.push(`  if ("errors" in expected) {`);
  lines.push(`    const expErr: any = (expected as any).errors;`);
  lines.push(`    const actErr: any = resp?.errors;`);
  lines.push(`    if (Array.isArray(expErr)) {`);
  lines.push(`      expect(actErr || []).toEqual(expErr);`);
  lines.push(`    } else {`);
  lines.push(`      expect(actErr).toEqual(expErr);`);
  lines.push(`    }`);
  lines.push(`  }`);
  lines.push("");
  lines.push(`  if ("data" in expected) {`);
  lines.push(`    const ok = subset((expected as any).data, resp?.data);`);
  lines.push("    if (!ok) {");
  lines.push("      const pretty = (v: any) => JSON.stringify(v, null, 2);");
  lines.push("      throw new Error(");
  lines.push("        `expected subset:\\n${pretty((expected as any).data)}\\n\\nactual:\\n${pretty(resp?.data)}`");
  lines.push("      );");
  lines.push("    }");
  lines.push("  }");
  lines.push("});");
  lines.push("");

  return lines.join("\n");
}

export function renderJestForOperation(params: RenderParams): string {
  const { operationName, scenarios } = params;
  const parts: string[] = [];
  parts.push(renderHeader(operationName));

  if (!Array.isArray(scenarios) || scenarios.length === 0) {
    parts.push(`test("no-scenarios-for-${escapeForTemplateLiteral(operationName)}", () => {`);
    parts.push(`  expect(true).toBe(true);`);
    parts.push("});");
    return parts.join("\n");
  }

  // Group by operation; a `describe` is nice but optionalâ€”keeping flat ensures
  // simple artifact mapping. If you prefer a describe wrapper, uncomment below:
  // parts.push(`describe(${JSON.stringify(operationName)}, () => {`);

  scenarios.forEach((sc, i) => {
    parts.push(renderTest(operationName, i, sc));
  });

  // parts.push("});");
  return parts.join("\n");
}
