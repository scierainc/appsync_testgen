// Version: renderers/pytest v1.1.1
import * as vscode from "vscode";

type OpType = "query" | "mutation" | "subscription";

// Make a safe Python filename: only letters, numbers, and underscores
export function makePyTestFileName(opName: string): string {
  // e.g., "Mutation.createCourse" -> "Mutation_createCourse"
  const safe = opName.replace(/[^A-Za-z0-9_]/g, "_");
  return `test_${safe}.py`;
}

export interface Scenario {
  id?: string;
  title?: string;
  level?: "unit" | "integration";
  gql: string;
  variables?: Record<string, unknown>;
  expected?: { data?: unknown; errors?: unknown };
  notes?: string;
}

export interface RenderParams {
  operationName: string;
  operationType: OpType;
  scenarios: Scenario[];
}

function indent(s: string, n: number): string {
  const pad = " ".repeat(n);
  return s
    .split("\n")
    .map((line) => (line.length ? pad + line : line))
    .join("\n");
}

// Safe python identifier: no hyphens/spaces, no leading digit
function safePyName(s: string, fallback: string): string {
  let out = (s || "").toLowerCase().replace(/[^a-z0-9_]+/g, "_");
  out = out.replace(/^_+/, "").replace(/_+$/, "");
  if (!out) out = fallback;
  if (/^[0-9]/.test(out)) out = `${fallback}_${out}`;
  return out;
}

function tripleQuotedGraphQL(gql: string): string {
  return `"""${gql.replace(/"""/g, '\\"""')}"""`;
}

/** Embed JSON as a raw triple-quoted string; parse with json.loads at runtime. */
function jsonAsRawTripleQuoted(obj: unknown): string {
  const json = JSON.stringify(obj ?? {}, null, 2);
  return `r'''${json}'''`;
}

function renderHeader(op: string): string {
  return [
    `# Generated by AppSync TestGen`,
    `# Operation: ${op}`,
    `import json`,
    `import pytest`, // <-- needed for @pytest.mark.* decorators
    `from graphql_client import gql_request`,
    ``,
    `# subset matcher for expected["data"]`,
    `def _subset(exp, got):`,
    `    if isinstance(exp, dict):`,
    `        if not isinstance(got, dict):`,
    `            return False`,
    `        return all(k in got and _subset(v, got[k]) for k, v in exp.items())`,
    `    if isinstance(exp, list):`,
    `        if not isinstance(got, list):`,
    `            return False`,
    `        # For each expected item, require at least one matching item in got`,
    `        return all(any(_subset(e, g) for g in got) for e in exp)`,
    `    return exp == got`,
    ``,
  ].join("\n");
}

/** derive pytest markers from scenario metadata to feed conftest summaries */
function markersForScenario(sc: Scenario): string[] {
  const hay = `${sc.id ?? ""} ${sc.title ?? ""} ${sc.notes ?? ""}`.toLowerCase();
  const out: string[] = [];
  if (/happy/.test(hay)) out.push("happy");
  if (/(validation|missing|invalid)/.test(hay)) out.push("validation");
  if (/(not[\s_-]*found|404)/.test(hay)) out.push("notfound");
  if (/(auth|forbidden|unauthorized|401|403)/.test(hay)) out.push("auth");
  return out.length ? out : [];
}

function renderTest(opName: string, opType: OpType, idx: number, sc: Scenario): string {
  // scenario id used for artifacts (keep as provided if present)
  const scenarioId = sc.id || `scenario_${String(idx + 1).padStart(3, "0")}`;

  // function name pieces
  const base = sc.id || sc.title || `scenario_${idx + 1}`;
  const scSlug = safePyName(base, "scenario");
  const seq = String(idx + 1).padStart(3, "0");

  // operation suffix at the end, e.g. "mutation_createCourse"
  const opField = (opName.split(".")[1] || opName).replace(/[^A-Za-z0-9_]/g, "_");
  const opSuffix = `${opType.toLowerCase()}_${opField}`;
  const testName = `test_${scSlug}_${seq}_${opSuffix}`;

  const gqlBlock = tripleQuotedGraphQL(sc.gql || "");
  const variablesBlock = jsonAsRawTripleQuoted(sc.variables ?? {});
  const expectedBlock = jsonAsRawTripleQuoted(sc.expected ?? {});

  const body = [
    `gql = ${gqlBlock}`,
    `variables = json.loads(${variablesBlock})`,
    // pass op & scenario so artifacts name correctly (and Allure attachment names improve)
    `resp = gql_request(gql, variables=variables, op=${JSON.stringify(opName)}, scenario=${JSON.stringify(scenarioId)})`,
    ``,
    `expected = json.loads(${expectedBlock})`,
    `# Normalize and compare errors: treat missing resp.errors as []`,
    `if "errors" in expected:`,
    `    exp_err = expected["errors"]`,
    `    act_err = resp.get("errors")`,
    `    if isinstance(exp_err, list):`,
    `        assert (act_err or []) == exp_err`,
    `    else:`,
    `        assert act_err == exp_err`,
    ``,
    `# Subset data match (if provided)`,
    `if "data" in expected:`,
    `    assert _subset(expected["data"], resp.get("data")), (`,
    `        f"expected subset:\\n{expected['data']}\\n\\nactual:\\n{resp.get('data')}"`,
    `    )`,
  ].join("\n");

  const doc = sc.title ? `    """${sc.title.replace(/"""/g, '\\"""')}"""` : "";

  // pytest marks (if any)
  const marks = markersForScenario(sc)
    .map((m) => `@pytest.mark.${m}`)
    .join("\n");

  return [
    marks,
    marks ? "" : "", // keep spacing consistent
    `def ${testName}():`,
    doc,
    indent(body, 4),
    ``,
  ]
    .filter(Boolean)
    .join("\n");
}

export function renderPytestForOperation(params: RenderParams): string {
  const { operationName, operationType, scenarios } = params;
  const parts: string[] = [];
  parts.push(renderHeader(operationName));

  if (!Array.isArray(scenarios) || scenarios.length === 0) {
    parts.push(`# No scenarios for ${operationName}`);
    return parts.join("\n");
  }

  scenarios.forEach((sc, i) => {
    parts.push(renderTest(operationName, operationType, i, sc));
  });

  return parts.join("\n");
}
